import { Uri } from 'monaco-editor';
import getConfigurationServiceOverride from '@codingame/monaco-vscode-configuration-service-override';
import { initServices, wasVscodeApiInitialized, mergeServices } from 'monaco-languageclient';
import { EditorAppExtended } from './editorAppExtended.js';
import { EditorAppClassic } from './editorAppClassic.js';
import { LanguageClientWrapper } from './languageClientWrapper.js';
import { Logger } from './logger.js';
/**
 * This class is responsible for the overall ochestration.
 * It inits, start and disposes the editor apps and the language client (if configured) and provides
 * access to all required components.
 */
export class MonacoEditorLanguageClientWrapper {
    id;
    editorApp;
    languageClientWrapper;
    serviceConfig;
    logger;
    init(userConfig) {
        if (userConfig.wrapperConfig.editorAppConfig.useDiffEditor && !userConfig.wrapperConfig.editorAppConfig.codeOriginal) {
            throw new Error('Use diff editor was used without a valid config.');
        }
        this.id = userConfig.id ?? Math.floor(Math.random() * 101).toString();
        this.logger = new Logger(userConfig.loggerConfig);
        this.serviceConfig = userConfig.wrapperConfig.serviceConfig ?? {};
    }
    async initServices() {
        // always set required services if not configure
        this.serviceConfig.userServices = this.serviceConfig.userServices ?? {};
        const configureService = this.serviceConfig.userServices.configure;
        if (!configureService) {
            const mlcDefautServices = {
                ...getConfigurationServiceOverride(Uri.file('/workspace'))
            };
            mergeServices(mlcDefautServices, this.serviceConfig.userServices);
        }
        mergeServices(this.editorApp?.specifyServices() ?? {}, this.serviceConfig.userServices);
        // overrule debug log flag
        this.serviceConfig.debugLogging = this.logger.isEnabled() && (this.serviceConfig.debugLogging || this.logger.isDebugEnabled());
        if (wasVscodeApiInitialized()) {
            this.logger.debug('No service init on restart', this.serviceConfig.debugLogging);
        }
        else {
            this.logger.debug('Init Services', this.serviceConfig.debugLogging);
            await initServices(this.serviceConfig);
        }
    }
    async start(userConfig, htmlElement) {
        if (!htmlElement) {
            throw new Error('No HTMLElement provided for monaco-editor.');
        }
        // Always dispose old instances before start
        this.editorApp?.disposeApp();
        this.init(userConfig);
        if (userConfig.wrapperConfig.editorAppConfig.$type === 'classic') {
            this.editorApp = new EditorAppClassic(this.id, userConfig, this.logger);
        }
        else {
            this.editorApp = new EditorAppExtended(this.id, userConfig, this.logger);
        }
        await this.initServices();
        this.languageClientWrapper = new LanguageClientWrapper(this.editorApp.getConfig().languageId, userConfig.languageClientConfig, this.logger);
        this.logger.info(`Starting monaco-editor (${this.id})`);
        await this.editorApp?.init();
        await this.editorApp.createEditors(htmlElement);
        if (this.languageClientWrapper.haveLanguageClientConfig()) {
            await this.languageClientWrapper.start();
        }
    }
    isStarted() {
        // fast-fail
        if (!this.editorApp?.haveEditor()) {
            return false;
        }
        if (this.languageClientWrapper.haveLanguageClient()) {
            return this.languageClientWrapper.isStarted();
        }
        return true;
    }
    getMonacoEditorApp() {
        return this.editorApp;
    }
    getEditor() {
        return this.editorApp?.getEditor();
    }
    getDiffEditor() {
        return this.editorApp?.getDiffEditor();
    }
    getLanguageClient() {
        return this.languageClientWrapper.getLanguageClient();
    }
    getModel(original) {
        return this.editorApp?.getModel(original);
    }
    getWorker() {
        return this.languageClientWrapper.getWorker();
    }
    async updateModel(modelUpdate) {
        await this.editorApp?.updateModel(modelUpdate);
    }
    async updateDiffModel(modelUpdate) {
        await this.editorApp?.updateDiffModel(modelUpdate);
    }
    reportStatus() {
        const status = [];
        status.push('Wrapper status:');
        status.push(`Editor: ${this.editorApp?.getEditor()}`);
        status.push(`DiffEditor: ${this.editorApp?.getDiffEditor()}`);
        return status;
    }
    async dispose() {
        this.editorApp?.disposeApp();
        if (this.languageClientWrapper.haveLanguageClient()) {
            await this.languageClientWrapper.disposeLanguageClient(false);
            this.editorApp = undefined;
            await Promise.resolve('Monaco editor and languageclient completed disposed.');
        }
        else {
            await Promise.resolve('Monaco editor has been disposed.');
        }
    }
    updateLayout() {
        this.editorApp?.updateLayout();
    }
}
//# sourceMappingURL=wrapper.js.map